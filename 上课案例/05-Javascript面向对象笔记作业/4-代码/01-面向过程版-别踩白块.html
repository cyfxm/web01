<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        *{
            margin: 0;
            padding: 0;
        }
        .score{
            margin-left: 50px;
            margin-top: 44px;
        }
        .box{
            width: 400px;
            height: 400px;
            margin-left: 50px;
            margin-top: 50px;
            border:1px solid blue;
            /* 父相 */
            position: relative;
            /* 溢出隐藏 */
            overflow: hidden;
        }
        .box .game {
            /* 因为后期我们需要让游戏区下落运动起来,所以需要给游戏区设置绝对定位 */
            /* 子绝 */
            position: absolute;
            top: -50px;
            left: 0;
        }
        .box .game .row div{
            width: 98px;
            height: 98px;
            border:1px solid gray;
            float: left;
        }
        .box .game .row .black{
            background: black;
        }
    </style>
</head>
<body>
    <!-- 1. HTML,CSS完成可视区以及游戏区的布局 -->
    <!-- 统计分数的文本框  disabled代表禁用属性,不能可以编辑-->
    <input type="text" class="score" value="0" disabled="disabled">
    
    <!-- 外层大盒子  可视区 -->
    <div class="box">
        <!-- 内层盒子 游戏区域 也就是需要一直向下运动并且可以点击的区域  -->
        <div class="game">
            <div class="row">
                <div class="black"></div>
                <div></div>
                <div></div>
                <div></div>
            </div>
            <div class="row">
                <div></div>
                <div class="black"></div>
                <div></div>
                <div></div>
            </div>
            <div class="row">
                <div></div>
                <div></div>
                <div class="black"></div>
                <div></div>
            </div>
            <div class="row">
                <div></div>
                <div></div>
                <div></div>
                <div class="black"></div>
            </div>
        </div>
    </div>

    <script>
        // 2.让game游戏区 动起来 向下运动(不断增加游戏区域的top值,让游戏动起来)
        // 获取game对象
        var game = document.querySelector(".game");

        // 8.1 定义一个全局变量speed保存游戏区下落的速度
        var speed = 1;

        // 向下运动就是使用定时器不断增加game游戏区的top值
        var timer = setInterval(function(){
            // 怎么获取当前game游戏区的相对父元素box的上外边距?  怎么设置偏移量top值变化?
            // offsetTop是一个只读属性,得到的是一个数值
            // style属性可以读写,但是读的时候,需要是行内式才可以读取到,得到的时候一个字符串的值,带单位
            game.style.top = game.offsetTop + speed + "px";

            // 3.动态添加一行
            // 3.1 什么时候添加一行? 当游戏区的top大于等于0的时候
            if( game.offsetTop >= 0){ // 代表到达底部
                // 9.运动到底部判断最后一行是否全部黑块被点击
                // 9.2 当game.offsetTop大于等于0的时候,代表移动到底部了
                // 9.3 判断游戏区最后一行上的自定义属性的值是否为null,
                // 如果获取自定义属性不存在,会得到null
                if( game.children[game.children.length - 1].getAttribute("pass") == null ){
                    // 如果是则清除定时器,设置游戏状态为结束,并且弹窗提示用户,最后加上一个return终止函数体后续的代码执行
                    window.clearInterval(timer);
                    gameover = true;
                    alert("游戏结束~");
                    return false;
                }


                // 5.删除底部多余的行 可视区中最多能够显示游戏区行黑白块,新行还没完全出现,最下面一行还没有完成消失,再加上中间3行; 如果游戏区中行数大于5,我们就删除最后一行
                // 如何得到game游戏层中的行数?
                // console.log( game.children.length );
                if( game.children.length >= 5 ){ // 到达底部以后,判断当前游戏区中的行数是不是大于等于5
                    // 删除game游戏区中的最后一行
                    // 父节点.removeChild(子节点)
                    // game.removeChild( game.lastElementChild );
                    game.removeChild( game.children[ game.children.length-1 ] );

                    // 指定节点.remove
                    // game.lastElementChild.remove();
                }


                // 3.2 如何动态创建一行 document.createElement
                var row = document.createElement("div");
                row.className = "row";

                // 4.随机创建黑块  因为我们刚才第3步创建行是没有黑块,如何给row行随机某个div设置黑块呢?  其实就是随机给row行某个div设置类名black即可
                // 4.1 随机得到 1 , 2, 3, 4之间的一个数
                var random = Math.floor( Math.random()*4 + 1);
                
                // 3.3 每行中有4个div格子
                for(var i = 1;i<=4;i++){
                    // 创建div标签
                    var div = document.createElement("div");
                    
                    // 4.2 如果当前的i等于我们的随机整数,我们就添加.black类,那么就是黑块
                    if(i == random ){
                        div.className = "black";
                    }

                    // 把div添加到row行中
                    row.appendChild(div);
                }
                // 3.4 把动态创建好的行,添加到游戏区的最前面,因为我们游戏区域是从上向下运动的,所以新添加的一行需要添加到游戏区子元素列表最前面
                // 语法:  父节点.insertbefore(子节点,指定位置)
                game.insertBefore(row, game.children[0] )
                // 3.5 重新将游戏区的top值设置-100px  这样看起来才像无缝滚动  因为一个行的高度就是100高,这样才可以让新行完整显示并下落
                game.style.top = "-100px";
            }

        },30)


        // 6.绑定点击事件 在事件中进行判断 点击的是黑块还是白块;如果是黑块就加分变白,白块就游戏结束;
        // 6.2 获取分数对象文本框
        var score = document.querySelector(".score");
        // 6.3 定义一个保存分数的全局变量
        var fenshu = 0;
        


        // 7.游戏结束后的判断和处理
        // 7.1 游戏结束了,此时黑白块都应该是不允许点击的了,而且点击黑块以后也不能加分
        // 7.2 定义一个全局变量保存游戏是否结束
        var gameover = false;// false代表游戏没有结束,true代表游戏结束
        // 使用事件委托绑定点击事件,这样就不需要给game中的row行每个div绑定单击事件
        game.onclick = function( e ){
            // 如果给了游戏区域绑定单击事件,如何得到我点击的那个小方块? 通过事件对象e.target属性得到触发事件目标对象
            e = e || window.event;
            // 6.1 如果点击的是黑块就加1分,黑块变白
            // console.log( e.target );
            // console.log( e.target.className );
            // 7.3 在判断点击黑白块之前,需要先判断游戏是否已经结束,如果结束了我们就弹窗提示用户游戏已经结束
            if( gameover ){
                alert("游戏结束,请重新开始");
            }else if( e.target.className == "black"){
                // 只需要移动div上面的.black类名即可
                e.target.removeAttribute("class");
                // 分数加1
                score.value = ++fenshu; 

                // 8.根据分数游戏加速(为了让游戏更有趣味性)
                // 8.2 判断全局变量fenshu是否是5的倍数(我们假设每多5分,就增加一次难度,调快下落的速度)
                // 8.3 在用户成功点击黑块以后,加完分之后,我们就判断当前分数是否为是5的倍数,如果是我们就增加下落的速度
                if( fenshu % 5 == 0){
                    // 让速度加快
                    speed++;
                }
                // 9.1 如果当前行的黑块被成功点击,我们就给这行添加一个自定义属性pass,并且赋值为true

                // 想得到点击那个黑块的对应所在行?怎么得到
                // 得到当前点击的那个黑块所在行
                // console.log( e.target.parentNode );
                // 设置一个自定义属性pass的为true,为true代表这行的黑块被点掉了
                e.target.parentNode.setAttribute("pass",true);

            }else{
                // 6.4 如果点击的白块就弹窗提示游戏结束 清除定时器
                alert("游戏结束");
                // 清除向下运动的定时器
                window.clearInterval( timer );
                // 7.4 如果点击的白块,除了清除定时器,还需要修改gameover的值为true
                gameover = true;
            }
        }
    </script>
</body>
</html>